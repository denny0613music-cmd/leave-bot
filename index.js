import "dotenv/config";
import http from "http";
import {
  Client,
  GatewayIntentBits,
  SlashCommandBuilder,
  REST,
  Routes,
  ActionRowBuilder,
  ButtonBuilder,
  ButtonStyle,
  ModalBuilder,
  TextInputBuilder,
  TextInputStyle,
  EmbedBuilder,
  MessageFlags,
} from "discord.js";

/* ===============================
   Render å¥åº·æª¢æŸ¥ï¼ˆä¸€å®šè¦ï¼‰
================================ */
const port = process.env.PORT || 3000;
http
  .createServer((req, res) => {
    res.writeHead(200, { "Content-Type": "text/plain; charset=utf-8" });
    res.end("ok");
  })
  .listen(port, () => {
    console.log(`HTTP server listening on ${port}`);
  });

/* ===============================
   Discord Client
================================ */
const client = new Client({
  intents: [GatewayIntentBits.Guilds],
});

/* ===============================
   Slash Command
================================ */
const CMD = new SlashCommandBuilder()
  .setName("setup_leave_button")
  .setDescription("åœ¨ç›®å‰é »é“ç™¼é€ã€Œè«‹å‡ã€æŒ‰éˆ•");

async function registerCommands() {
  const { DISCORD_TOKEN, CLIENT_ID, GUILD_ID } = process.env;

  if (!DISCORD_TOKEN || !CLIENT_ID || !GUILD_ID) {
    throw new Error("ç¼ºå°‘ DISCORD_TOKEN / CLIENT_ID / GUILD_ID");
  }

  const rest = new REST({ version: "10" }).setToken(DISCORD_TOKEN);
  await rest.put(Routes.applicationGuildCommands(CLIENT_ID, GUILD_ID), {
    body: [CMD.toJSON()],
  });

  console.log("âœ… Slash command registered");
}

client.once("clientReady", async () => {
  console.log(`âœ… Logged in as ${client.user.tag}`);
  try {
    await registerCommands();
  } catch (err) {
    console.error("âŒ registerCommands error:", err);
  }
});

/* ===============================
   Builder helpers
================================ */
function buildLeaveButtonMessage() {
  const row = new ActionRowBuilder().addComponents(
    new ButtonBuilder()
      .setCustomId("leave_button")
      .setLabel("ðŸ“© è«‹å‡ç”³è«‹")
      .setStyle(ButtonStyle.Primary)
  );

  const embed = new EmbedBuilder()
    .setTitle("è«‹å‡ç”³è«‹")
    .setDescription("æŒ‰ä¸‹æŒ‰éˆ•å¾Œæœƒè·³å‡ºè¡¨å–®ï¼Œå¡«å®Œé€å‡ºå³å¯ã€‚");

  return { embeds: [embed], components: [row] };
}

function buildLeaveModal() {
  const modal = new ModalBuilder()
    .setCustomId("leave_modal")
    .setTitle("è«‹å‡è¡¨å–®");

  modal.addComponents(
    new ActionRowBuilder().addComponents(
      new TextInputBuilder()
        .setCustomId("leave_dates")
        .setLabel("è«‹å‡æ™‚é–“")
        .setStyle(TextInputStyle.Short)
        .setRequired(true)
    ),
    new ActionRowBuilder().addComponents(
      new TextInputBuilder()
        .setCustomId("leave_reason")
        .setLabel("åŽŸå› ")
        .setStyle(TextInputStyle.Paragraph)
        .setRequired(true)
    ),
    new ActionRowBuilder().addComponents(
      new TextInputBuilder()
        .setCustomId("leave_note")
        .setLabel("å‚™è¨»ï¼ˆå¯é¸ï¼‰")
        .setStyle(TextInputStyle.Paragraph)
        .setRequired(false)
    )
  );

  return modal;
}

function safeGet(interaction, id, fallback = "") {
  try {
    const v = interaction.fields.getTextInputValue(id);
    return typeof v === "string" ? v : fallback;
  } catch {
    return fallback;
  }
}

/* ===============================
   Interaction handler
================================ */
client.on("interactionCreate", async (interaction) => {
  try {
    /* /setup_leave_button */
    if (
      interaction.isChatInputCommand() &&
      interaction.commandName === "setup_leave_button"
    ) {
      await interaction.reply({
        content: "âœ… å·²åœ¨æ­¤é »é“å»ºç«‹è«‹å‡æŒ‰éˆ•",
        flags: MessageFlags.Ephemeral,
      });

      await interaction.channel.send(buildLeaveButtonMessage());
      return;
    }

    /* Button -> Modalï¼ˆ3 ç§’å…§ä¸€å®šè¦ï¼‰ */
    if (interaction.isButton() && interaction.customId === "leave_button") {
      await interaction.showModal(buildLeaveModal());
      return;
    }

    /* Modal submit */
    if (
      interaction.isModalSubmit() &&
      interaction.customId === "leave_modal"
    ) {
      await interaction.deferReply({
        flags: MessageFlags.Ephemeral,
      });

      const dates = safeGet(interaction, "leave_dates");
      const reason = safeGet(interaction, "leave_reason");
      const noteRaw = safeGet(interaction, "leave_note");
      const note = noteRaw.trim() ? noteRaw : "ï¼ˆç„¡ï¼‰";

      const embed = new EmbedBuilder()
        .setTitle("ðŸ“Œ æ–°çš„è«‹å‡ç”³è«‹")
        .addFields(
          { name: "ç”³è«‹äºº", value: `${interaction.user}` },
          { name: "æ™‚é–“", value: dates || "ï¼ˆæœªå¡«ï¼‰" },
          { name: "åŽŸå› ", value: reason || "ï¼ˆæœªå¡«ï¼‰" },
          { name: "å‚™è¨»", value: note }
        )
        .setTimestamp();

      const leaveChannelId = process.env.LEAVE_CHANNEL_ID;
      if (!leaveChannelId) {
        await interaction.editReply("âŒ æœªè¨­å®š LEAVE_CHANNEL_ID");
        return;
      }

      const channel = await client.channels
        .fetch(leaveChannelId)
        .catch(() => null);

      if (!channel || !channel.isTextBased()) {
        await interaction.editReply("âŒ è«‹å‡é »é“ä¸å­˜åœ¨æˆ–ä¸æ˜¯æ–‡å­—é »é“");
        return;
      }

      await channel.send({ embeds: [embed] });
      await interaction.editReply("âœ… å·²é€å‡ºè«‹å‡ç”³è«‹");
      return;
    }
  } catch (err) {
    console.error("âŒ interaction error:", err);

    if (
      interaction.isRepliable() &&
      !interaction.replied &&
      !interaction.deferred
    ) {
      await interaction
        .reply({
          content: "âŒ ç™¼ç”ŸéŒ¯èª¤ï¼Œè«‹ç¨å¾Œå†è©¦",
          flags: MessageFlags.Ephemeral,
        })
        .catch(() => {});
    }
  }
});

client.login(process.env.DISCORD_TOKEN);
